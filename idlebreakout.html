<!DOCTYPE HTML>
<html>

<head>
    <style>
        #canvas {
            border-style: solid;
            border-width: 2px;
        }
    </style>
</head>

<body>
    <canvas id="canvas" height="1000" width="1000"> </canvas>
</body>

</html>
<script>
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    canvas.height = window.innerHeight - 25;
    canvas.width = window.innerWidth - 25;

    //circle properties
    var numberOfCircles = 300;
    var speed = 5;
    var radius = 5;
    var intervalFrequency = 5;
    var numberOfGridRows = 15;
    var numberOfGridColumns = 15;
    var blockHeight = 15;
    var blockWidth = 20;
    var blockWidthGap = 10;
    var blockHeightGap = 10;
    var blockHealth = 10;
    var circleDamage = 1;

    //setting starter vars grid
    var blocks = [];
    var totalBlockWidth = numberOfGridColumns * (blockWidth + blockWidthGap);
    var totalBlockHeight = numberOfGridColumns * (blockHeight + blockHeightGap);
    var startingX = window.innerWidth / 2 - (totalBlockWidth / 2);
    var startingY = window.innerHeight / 2 - (totalBlockHeight / 2)
    for (var i = 0; i < numberOfGridRows; i++) {
        for (var j = 0; j < numberOfGridColumns; j++) {
            blocks.push({
                posx: j * (blockWidth + blockWidthGap) + startingX,
                posy: i * (blockHeight + blockHeightGap) + startingY,
                height: blockHeight,
                width: blockWidth,
                health: blockHealth
            })
        }
    }

    //setting starter vars for circles
    var circles = [];
    for (var i = 0; i < numberOfCircles; i++) {
        var thisCircleSpeedX = Math.floor(Math.random() * 2);
        var thisCircleSpeedY = Math.floor(Math.random() * 2);
        if (thisCircleSpeedX === 1) {
            thisCircleSpeedX = speed;
        } else {
            thisCircleSpeedX = speed * -1;
        }
        if (thisCircleSpeedY === 1) {
            thisCircleSpeedY = speed;
        } else {
            thisCircleSpeedY = speed * -1;
        }
        circles[i] = {
            posx: (Math.floor(Math.random() * (window.innerWidth - 75))) + 25,
            posy: (Math.floor(Math.random() * (window.innerHeight - 75))) + 25,
            speedX: thisCircleSpeedX,
            speedY: thisCircleSpeedY,
        }
        while (circles[i].posx >= startingX && circles[i].posx <= startingX + totalBlockWidth && circles[i].posy >= startingY && circles[i].posy <= startingY + totalBlockHeight) {
            circles[i].posx = (Math.floor(Math.random() * (window.innerWidth - 75))) + 25;
            circles[i].posy = (Math.floor(Math.random() * (window.innerHeight - 75))) + 25;
        }
    }

    //canvas display
    var canvasDisplay = setInterval(main, intervalFrequency);

    function wallCollisionCheck(index) {
        if (circles[index].posy + radius >= window.innerHeight - 25) {
            circles[index].speedY = speed * -1;
        }
        if (circles[index].posx + radius >= window.innerWidth - 25) {
            circles[index].speedX = speed * -1;
        }
        if (circles[index].posx - radius <= 0) {
            circles[index].speedX = speed;
        }
        if (circles[index].posy - radius <= 0) {
            circles[index].speedY = speed;
        }
    }
    function blockVerticalCollisionCheck(index,oldXPos,oldYPos) {
        for (var j = 0; j < blocks.length; j++) {
            if (circles[index].posx + radius >= blocks[j].posx && circles[index].posx - radius <= blocks[j].posx + blocks[j].width && circles[index].posy + radius >= blocks[j].posy && circles[index].posy - radius <= blocks[j].posy + blocks[j].height) {
                circles[index].speedX = circles[index].speedX * -1;
                circles[index].posx = oldXPos;
                blockHealthDown(j);
            }
        }
    }
    function blockHorizontalCollisionCheck(index,oldXPos,oldYPos) {
        for (var j = 0; j < blocks.length; j++) {
            if (circles[index].posx + radius >= blocks[j].posx && circles[index].posx - radius <= blocks[j].posx + blocks[j].width && circles[index].posy + radius >= blocks[j].posy && circles[index].posy - radius <= blocks[j].posy + blocks[j].height) {
                circles[index].speedY = circles[index].speedY * -1;
                circles[index].posy = oldYPos;
                blockHealthDown(j);
            }
        }
    }
    function blockHealthDown(blockIndex) {
        blocks[blockIndex].health -= circleDamage;

        if (blocks[blockIndex].health <= 0) {
            blocks.splice(blockIndex, 1);
        }
    }
    function main() {
        ctx.clearRect(0, 0, 1000000, 1000000);
        ctx.fillStyle = "black"
        for (var i = 0; i < circles.length; i++) {
            var safeXPos = circles[i].posx;
            var safeYPos = circles[i].posy;
            circles[i].posx += circles[i].speedX;
            blockVerticalCollisionCheck(i,safeXPos,safeYPos);
            circles[i].posy += circles[i].speedY;
            blockHorizontalCollisionCheck(i,safeXPos,safeYPos);
            wallCollisionCheck(i);
            ctx.beginPath();
            ctx.arc(circles[i].posx, circles[i].posy, radius, 0, 2 * Math.PI);
            ctx.fill();
        }
        for (var i = 0; i < blocks.length; i++) {
            ctx.fillStyle = "rgb(" + (256 - (256 * (blocks[i].health / blockHealth))) + ", 0, 0)"
            ctx.fillRect(blocks[i].posx, blocks[i].posy, blocks[i].width, blocks[i].height)
        }
    }
</script>