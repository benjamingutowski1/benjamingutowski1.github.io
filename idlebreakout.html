<!DOCTYPE HTML>
<html>

<head>
    <style>
        #canvas {
            border-style: solid;
            border-width: 2px;
        }
    </style>
</head>

<body>
    <canvas id="canvas" height="1000" width="1000"> </canvas>
</body>

</html>
<script>
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    canvas.height = window.innerHeight - 25;
    canvas.width = window.innerWidth - 25;

    //circle properties
    var numberOfStartingCircles = 500;
    var speed = 5;
    var radius = 3;
    var intervalFrequency = 5;
    var numberOfGridRows = 3;
    var numberOfGridColumns = 3;
    var blockHeight = 100;
    var blockWidth = 100;
    var blockWidthGap = 20;
    var blockHeightGap = 20;
    var blockHealth = 10000;
    var menuHeight = 100;
    var circleDamage = 1;
    var menuContents = [{ posx: 1, posy: 1, height: 90, width: 90, text: ["create", "ball"], background_color: "#ffffff", text_color: "#000000", font_size: 30, id: 1}];

    //magic numbers for boxClicks
    var createBallsBox = 1;

    //setting starter vars grid
    var blocks = [];
    var totalBlockWidth = numberOfGridColumns * (blockWidth + blockWidthGap);
    var totalBlockHeight = numberOfGridColumns * (blockHeight + blockHeightGap);
    var startingX = window.innerWidth / 2 - (totalBlockWidth / 2);
    var startingY = window.innerHeight / 2 - (totalBlockHeight / 2) + (menuHeight / 2);
    for (var i = 0; i < numberOfGridRows; i++) {
        for (var j = 0; j < numberOfGridColumns; j++) {
            blocks.push({
                posx: j * (blockWidth + blockWidthGap) + startingX,
                posy: i * (blockHeight + blockHeightGap) + startingY,
                height: blockHeight,
                width: blockWidth,
                health: blockHealth
            })
        }
    }

    //setting starter vars for circles
    var circles = [];
    for (var i = 0; i < numberOfStartingCircles; i++) {
        var thisCircleSpeedX = Math.floor(Math.random() * 2);
        var thisCircleSpeedY = Math.floor(Math.random() * 2);
        if (thisCircleSpeedX === 1) {
            thisCircleSpeedX = speed;
        } else {
            thisCircleSpeedX = speed * -1;
        }
        if (thisCircleSpeedY === 1) {
            thisCircleSpeedY = speed;
        } else {
            thisCircleSpeedY = speed * -1;
        }
        circles[i] = {
            posx: (Math.floor(Math.random() * (window.innerWidth - 75))) + 25,
            posy: (Math.floor(Math.random() * (window.innerHeight - 75 - menuHeight))) + 25 + menuHeight,
            speedX: thisCircleSpeedX,
            speedY: thisCircleSpeedY,
        }
        while (circles[i].posx >= startingX && circles[i].posx <= startingX + totalBlockWidth && circles[i].posy >= startingY && circles[i].posy <= startingY + totalBlockHeight) {
            circles[i].posx = (Math.floor(Math.random() * (window.innerWidth - 75))) + 25;
            circles[i].posy = (Math.floor(Math.random() * (window.innerHeight - 75 - menuHeight))) + 25 + menuHeight;
        }
    }
    
    //EVERYTHING clicking
    document.getElementById("canvas").addEventListener("click", boxClickDetection);

    function boxClickDetection(e) {
        for (var i = 0; i < menuContents.length; i++) {
            if (e.clientX >= menuContents[i].posx &&
            e.clientX <= menuContents[i].posx + menuContents[i].width &&
            e.clientY >= menuContents[i].posy &&
            e.clientY <= menuContents[i].posy + menuContents[i].height) {
                clickID(menuContents[i].id);
            }
        }
    }
    
    //click ids and what they do
    function clickID(clickedID) {
        if (clickedID === createBallsBox) {
            alert("create ball :)")
        }
    }

    //canvas display
    var canvasDisplay = setInterval(main, intervalFrequency);

    //creates menu
    function createMenu() {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, window.innerWidth - 25, menuHeight);
        for (var i = 0; i < menuContents.length; i++) {
            ctx.fillStyle = menuContents[i].background_color;
            ctx.fillRect(menuContents[i].posx, menuContents[i].posy, menuContents[i].width, menuContents[i].height);
            var textXPos = menuContents[i].posx + 5;
            var textYPos = menuContents[i].posy + 5;
            ctx.fillStyle = menuContents[i].text_color;
            ctx.font = menuContents[i].font_size + "px Arial"
            for (var j = 0; j < menuContents[i].text.length; j++) {
                ctx.fillText(menuContents[i].text[j], menuContents[i].posx + 5, menuContents[i].posy + ((j + 1) * (10 + menuContents[i].font_size)), menuContents[i].width - 10)
            }
        }
    }

    //checks wall collisions for circles
    function wallCollisionCheck(index) {
        if (circles[index].posy + radius >= canvas.height) {
            circles[index].speedY = speed * -1;
        }
        if (circles[index].posx + radius >= canvas.width) {
            circles[index].speedX = speed * -1;
        }
        if (circles[index].posx - radius <= 0) {
            circles[index].speedX = speed;
        }
        if (circles[index].posy - radius <= menuHeight) {
            circles[index].speedY = speed;
        }
    }

    //checks after x position change
    function blockVerticalCollisionCheck(index, oldXPos, oldYPos) {
        for (var j = 0; j < blocks.length; j++) {
            if (circles[index].posx + radius >= blocks[j].posx &&
                circles[index].posx - radius <= blocks[j].posx + blocks[j].width &&
                circles[index].posy + radius >= blocks[j].posy &&
                circles[index].posy - radius <= blocks[j].posy + blocks[j].height) {
                circles[index].speedX = circles[index].speedX * -1;
                circles[index].posx = oldXPos;
                blockHealthDown(j);
            }
        }
    }

    //checks after y position change
    function blockHorizontalCollisionCheck(index, oldXPos, oldYPos) {
        for (var j = 0; j < blocks.length; j++) {
            if (circles[index].posx + radius >= blocks[j].posx &&
                circles[index].posx - radius <= blocks[j].posx + blocks[j].width &&
                circles[index].posy + radius >= blocks[j].posy &&
                circles[index].posy - radius <= blocks[j].posy + blocks[j].height) {
                circles[index].speedY = circles[index].speedY * -1;
                circles[index].posy = oldYPos;
                blockHealthDown(j);
            }
        }
    }

    //takes away health from a block
    function blockHealthDown(blockIndex) {
        blocks[blockIndex].health -= circleDamage;

        if (blocks[blockIndex].health <= 0) {
            blocks.splice(blockIndex, 1);
        }
    }

    //draws canvas
    function main() {
        ctx.clearRect(0, 0, 1000000, 1000000);
        createMenu();
        ctx.fillStyle = "black"
        for (var i = 0; i < circles.length; i++) {
            var safeXPos = circles[i].posx;
            var safeYPos = circles[i].posy;
            circles[i].posx += circles[i].speedX;
            blockVerticalCollisionCheck(i, safeXPos, safeYPos);
            circles[i].posy += circles[i].speedY;
            blockHorizontalCollisionCheck(i, safeXPos, safeYPos);
            wallCollisionCheck(i);
            ctx.beginPath();
            ctx.arc(circles[i].posx, circles[i].posy, radius, 0, 2 * Math.PI);
            ctx.fill();
        }
        for (var i = 0; i < blocks.length; i++) {
            ctx.fillStyle = "rgb(" + (256 - (256 * (blocks[i].health / blockHealth))) + ", 0, 0)"
            ctx.fillRect(blocks[i].posx, blocks[i].posy, blocks[i].width, blocks[i].height)
        }
    }
</script>